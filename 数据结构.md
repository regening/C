# 14天学习数据结构

## **DAY 1. C语言基础复习**

### 1.1 数据类型

C语言支持多种基本数据类型，以下是常见的类型：

* **整型（int）**：用于表示整数值。
* **字符型（char）**：用于表示单个字符。
* **浮点型（float, double）**：用于表示带小数的数值，`double`精度比`float`更高。
* **void**：表示无类型，通常用于函数返回值为空时。

**示例**：

```c
int a = 10;      // 整数类型
char c = 'A';    // 字符类型
float f = 3.14;  // 单精度浮点类型
double d = 3.14159; // 双精度浮点类型
```

---

### 1.2 数组与指针

**数组**：数组是一组相同类型数据的集合，可以通过索引访问。

**指针**：指针是一个变量，它存储的是另一个变量的地址。

* 数组名其实是指向数组首元素的指针。

**示例**：

```c
int arr[5] = {1, 2, 3, 4, 5};  // 数组定义
int *p = arr;  // 指针p指向数组arr的首元素

// 通过指针访问数组元素
printf("%d\n", *(p + 2));  // 输出3 (arr[2])
```

---

### 1.3 结构体

**结构体（struct）**：结构体是C语言中的一种自定义数据类型，用于将不同类型的数据组合在一起。

**示例**：

```c
struct Person {
    char name[20];
    int age;
};

struct Person p1 = {"Alice", 20};  // 创建结构体变量p1
printf("%s is %d years old.\n", p1.name, p1.age);   // 访问结构体成员
```
---


### 1.4 动态内存管理

在C语言中，使用`malloc`和`free`函数来动态分配和释放内存：

* `malloc(size)`：分配指定大小的内存。
* `free(ptr)`：释放通过`malloc`分配的内存。

**示例**：

```c
int *p = (int *)malloc(sizeof(int) * 5);  // 分配5个int大小的内存

if (p == NULL) {
    printf("Memory allocation failed.\n");
} else {
    p[0] = 10;  // 使用动态分配的内存
    printf("%d\n", p[0]);
    free(p);  // 释放内存
}
```

---

### **1.5 函数**

C语言中的函数是一个代码块，用于执行特定的任务。函数有返回值和参数。

**示例**：

```c
int add(int a, int b) { // 定义函数
    return a + b;
}

int main() {
    int result = add(5, 3);  // 调用函数
    printf("Result: %d\n", result);  // 输出8
    return 0;
}
```

---

## **DAY 2. 线性数据结构基础**

### **2.1 数组**

数组是存储相同类型元素的集合。它是线性数据结构的一种，能够通过索引（下标）直接访问元素。

**数组的特点**：

* **固定大小**：在声明时，数组的大小是固定的。
* **连续内存**：数组的元素在内存中是连续存储的。
* **随机访问**：通过下标可以直接访问任意元素，访问速度为O(1)。

**数组的基本操作**：

* **初始化**：在定义数组时可以为其元素赋初值。
* **访问元素**：通过下标访问元素。
* **修改元素**：直接通过下标修改元素值。

```c
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};  // 初始化数组

    for (int i = 0; i < 5; i++) {   // 遍历数组并打印元素
        printf("arr[%d] = %d\n", i, arr[i]);
    }

    arr[2] = 10;    // 修改数组元素
    printf("change arr[2] = %d\n", arr[2]);

    return 0;
}
// 输出：
// arr[0] = 1
// arr[1] = 2
// arr[2] = 3
// arr[3] = 4
// arr[4] = 5
// Updated arr[2] = 10
```

**ps**：数组的大小是固定的，不能动态改变。若需要动态大小，可以使用指针和`malloc`。

---

### **2.2 链表**

**链表****是一种灵活的线性数据结构，允许动态地管理数据。通过链表的指针，我们可以轻松地插入、删除和遍历数据。尽管它比数组在访问速度上稍逊一筹，但在内存管理和插入/删除操作上具有显著优势。

**链表**是一种动态的数据结构，它由一组**节点（Node）**组成。每个节点包含两部分：

1. **数据部分**：存储节点的数据。
2. **指针部分**：指向下一个节点的指针（或引用）。

与数组不同，链表的元素不在内存中是连续存储的，而是通过指针连接在一起。链表的大小是动态的，可以在运行时根据需要增加或删除节点。

---

**链表的结构：**

链表的基本结构由节点组成。每个节点包含：

* **数据部分**：存储数据。
* **指针部分**：指向下一个节点的指针，通常是一个指向结构体的指针。

```c
// 简单链表节点定义：
struct Node {
    int data;          // 数据部分
    struct Node* next; // 指向下一个节点的指针
};
```

---

**链表的种类：**

1. **单向链表**：

   * 每个节点只包含一个指向下一个节点的指针。
   * 最后一个节点的指针指向`NULL`，表示链表的结束。

2. **双向链表**：

   * 每个节点包含两个指针：一个指向下一个节点，另一个指向前一个节点。
   * 可以从任意方向（前向或后向）遍历链表。

3. **循环链表**：

   * 最后一个节点的指针指向头节点，形成一个环状结构。
   * 可以是单向循环链表或双向循环链表。

---

#### **优点**：

* **动态大小**：链表的大小是动态的，可以在运行时根据需要扩展或缩减，不需要提前定义大小。
* **高效的插入与删除**：链表的插入和删除操作（尤其是在头部或中间）是高效的，仅需要调整指针，不需要移动元素（不像数组那样）。
* **灵活的内存分配**：链表的节点在内存中不是连续存储的，可以更灵活地管理内存。

#### **缺点**：

* **访问速度慢**：链表的元素在内存中不连续，因此无法像数组一样通过索引直接访问，访问每个元素需要从头节点逐一遍历，时间复杂度为O(n)。
* **额外的空间开销**：每个节点需要额外存储一个指向下一个节点的指针，导致额外的空间开销。
* **指针管理复杂**：链表的指针操作比较复杂，容易出现指针错误，特别是在插入和删除操作时。

---

**链表应用场景：**

1. **动态数据结构**：当数据的数量在程序运行过程中不断变化时，链表提供了灵活的内存管理方式。
2. **需要频繁插入/删除的场景**：如果你需要频繁地在数据中间插入或删除元素，链表比数组更高效。
3. **队列和栈的实现**：链表可以方便地实现队列和栈这类数据结构。
4. **内存管理**：一些内存分配和垃圾回收机制也使用链表来跟踪和管理内存块。

---


### **2.3 链表应用**


链表是一种动态数据结构，其中的元素（节点）包含数据部分和指向下一个节点的指针。链表的大小是动态的，可以在运行时调整。

**链表的特点**：

* **动态大小**：链表的大小在运行时可随时增加或减少。
* **节点存储**：每个节点包含数据和指向下一个节点的指针。
* **线性访问**：遍历链表时，必须从头节点开始，逐个访问下一个节点，直到到达链表的末尾。

**链表的基本操作**：

* **创建链表**：动态分配内存创建节点。
* **插入节点**：在链表头部、尾部或中间插入节点。
* **删除节点**：删除特定节点。
* **遍历链表**：从头节点开始遍历链表并访问每个节点的数据。

```c
// 实现一个简单的单向链表，包含插入、删除和遍历操作。
#include <stdio.h>
#include <stdlib.h>

struct Node {   // 定义节点结构体
    int data;
    struct Node *next;
};

struct Node* point(int data) {    // 创建一个新节点
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

void print(struct Node* head) {    // 遍历链表并打印节点数据
    struct Node* current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

void insert(struct Node** head, int data) {   // 插入节点到链表的头部
    struct Node* newNode = point(data);
    newNode->next = *head;
    *head = newNode;
}

void delete(struct Node** head) {   // 删除链表的头部节点
    if (*head != NULL) {
        struct Node* temp = *head;
        *head = (*head)->next;
        free(temp);
    }
}

int main() {
    struct Node* head = NULL;

    insert(&head, 10);    // 插入节点
    insert(&head, 20);
    insert(&head, 30);
    
    printf("Linked List: ");
    print(head);

    delete(&head);    // 删除头部节点
    printf("After deleting head: ");
    print(head);

    return 0;
}
// 输出：
// Linked List: 30 -> 20 -> 10 -> NULL
// After deleting head: 20 -> 10 -> NULL
```

---

### **2.4 数组与链表的比较**

| 特点        | 数组         | 链表            |
| --------- | ---------- | ------------- |
| **大小**    | 固定         | 动态            |
| **内存布局**  | 连续         | 非连续           |
| **访问时间**  | O(1)（随机访问） | O(n)（顺序访问）    |
| **插入/删除** | O(n)（移动元素） | O(1)（头部插入/删除） |
| **内存使用**  | 固定内存       | 动态内存          |

---




## **DAY 3. 栈与队列**         

### **3.1 栈**

栈是一种**后进先出**的线性数据结构。它只有一个端口，可以进行的操作有：

* **入栈 Push**：将元素加入栈顶。
* **出栈 Pop**：从栈顶移除元素。
* **栈顶 Peek**：查看栈顶的元素，但不移除它。

**栈的特点**：

* 栈是单端操作的结构，元素的插入和删除都发生在同一端。
* 栈的操作是通过**指针**或**数组**来实现的。

**栈的应用**：

* **括号匹配**：用于验证数学表达式中的括号是否匹配。
* **浏览器的历史记录**：浏览器中的前进后退操作。
* **递归函数调用**：程序执行时，系统使用栈来保存函数调用的状态。

**栈的实现**：可以使用数组或链表来实现栈。

```c
// 使用数组来实现栈
#include <stdio.h>
#include <stdlib.h>

#define MAX 5  // 栈的最大大小

struct Stack {
    int arr[MAX];
    int top;
};

void start(struct Stack* stack) {   // 初始化栈
    stack->top = -1;
}

int Empty(struct Stack* stack) {      // 判断栈是否为空
    return stack->top == -1;
}

int Full(struct Stack* stack) {       // 判断栈是否为满
    return stack->top == MAX - 1;
}

void push(struct Stack* stack, int data) {      // 入栈操作
    if (Full(stack)) {
        printf("Stack Overflow\n");
    } else {
        stack->arr[++(stack->top)] = data;
        printf("Pushed %d onto stack\n", data);
    }
}

int pop(struct Stack* stack) {      // 出栈操作
    if (Empty(stack)) {
        printf("Stack Underflow\n");
        return -1;
    } else {
        return stack->arr[(stack->top)--];
    }
}

int peek(struct Stack* stack) {     // 查看栈顶元素
    if (Empty(stack)) {
        printf("Stack is empty\n");
        return -1;
    } else {
        return stack->arr[stack->top];
    }
}

int main() {
    struct Stack stack;
    start(&stack);

    push(&stack, 10);
    push(&stack, 20);
    push(&stack, 30);

    printf("Top is %d\n", peek(&stack));
    
    printf("Popped  is %d\n", pop(&stack));
    printf("Popped  is %d\n", pop(&stack));

    return 0;
}
// 输出：
/* Pushed 10 onto stack
   Pushed 20 onto stack
   Pushed 30 onto stack
   Top is 30
   Popped is 30
   Popped is 20*/
```

---

### **3.2 队列**                                 

队列是一种**先进先出**的线性数据结构。它允许在一端进行插入操作（队尾），在另一端进行删除操作（队头）。

**队列的基本操作**：

* **入队 Enqueue**：将元素加入队列的尾部。
* **出队 Dequeue**：从队列的头部移除元素。
* **队头 Front**：查看队列的第一个元素，但不移除它。

**队列的应用**：

* **任务调度**：操作系统中，任务的调度可以使用队列来管理。
* **打印任务管理**：打印机中打印任务的管理也是基于队列的。
* **消息队列**：在进程间通信中，经常使用队列来传递消息。

**队列的实现**：
队列也可以使用数组或链表来实现。

```c
// 使用数组实现队列
#include <stdio.h>
#include <stdlib.h>

#define MAX 5  // 队列的最大大小

struct Queue {
    int arr[MAX];
    int front, rear;
};

void initQueue(struct Queue* queue) {   // 初始化队列
    queue->front = -1;
    queue->rear = -1;
}

int isEmpty(struct Queue* queue) {  // 判断队列是否为空
    return queue->front == -1;
}

int isFull(struct Queue* queue) {   // 判断队列是否为满
    return queue->rear == MAX - 1;
}

void enqueue(struct Queue* queue, int data) {   // 入队操作
    if (isFull(queue)) {
        printf("Queue Overflow\n");
    } else {
        if (queue->front == -1)  // 如果队列为空
            queue->front = 0;
        queue->arr[++(queue->rear)] = data;
        printf("Enqueued %d to queue\n", data);
    }
}

int dequeue(struct Queue* queue) {  // 出队操作
    if (isEmpty(queue)) {
        printf("Queue Underflow\n");
        return -1;
    } else {
        int data = queue->arr[queue->front];
        if (queue->front == queue->rear) {  // 队列中只有一个元素
            queue->front = queue->rear = -1;  // 清空队列
        } else {
            queue->front++;
        }
        return data;
    }
}

int front(struct Queue* queue) {    // 查看队头元素
    if (isEmpty(queue)) {
        printf("Queue is empty\n");
        return -1;
    } else {
        return queue->arr[queue->front];
    }
}

int main() {
    struct Queue queue;
    initQueue(&queue);

    enqueue(&queue, 10);
    enqueue(&queue, 20);
    enqueue(&queue, 30);

    printf("Front element is %d\n", front(&queue));

    printf("Dequeued element is %d\n", dequeue(&queue));
    printf("Dequeued element is %d\n", dequeue(&queue));

    return 0;
}
// 输出：
/*Enqueued 10 to queue
  Enqueued 20 to queue
  Enqueued 30 to queue
  Front element is 10
  Dequeued element is 10
  Dequeued element is 20*/
```

---

## **DAY 4. 链表的高级操作**

### **4.1 双向链表**

双向链表与单向链表不同，它的每个节点不仅包括指向下一个节点的指针，还包括指向前一个节点的指针。使得可以在链表中喜爱嗯前或向后遍历。

**双向链表的结构**

每个节点有三个部分：

1. **数据部分**：存储节点的数据。
2. **指向下一个节点的指针 next**。
3. **指向前一个节点的指针 prev**。

```c
struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
};
```

**双向链表的操作**

* **插入节点**：可以在任意位置插入新节点（头部、尾部、指定位置）。
* **删除节点**：可以删除指定节点。
* **遍历链表**：可以从头部向尾部遍历，也可以从尾部向头部遍历。

```c
#include <stdio.h>
#include <stdlib.h>
struct Node {                                         // 定义双向链表节点结构
    int data;
    struct Node* next;
    struct Node* prev;
};
struct Node* create(int data) {                       // 创建新节点
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    newNode->prev = NULL;
    return newNode;
}

void insert(struct Node** head, int data) {          // 插入节点到链表头部
    struct Node* newNode = create(data);
    newNode->next = *head;
    if (*head != NULL) {
        (*head)->prev = newNode;                     // 如果链表非空，更新头节点的prev指针
    }
    *head = newNode;
}
void Forward(struct Node* head) {                    // 打印双向链表（从头到尾）
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d <-> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}
void Backward(struct Node* head) {                  // 打印双向链表（从尾到头）
    struct Node* temp = head;
    if (temp == NULL) return;
    while (temp->next != NULL) {                    // 移动到链表的最后一个节点
        temp = temp->next;
    }
    while (temp != NULL) {                          // 从尾到头遍历
        printf("%d <-> ", temp->data);
        temp = temp->prev;
    }
    printf("NULL\n");
}
void delete(struct Node** head) {                   // 删除头节点
    if (*head == NULL) return;
    struct Node* temp = *head;
    *head = (*head)->next;
    if (*head != NULL) {
        (*head)->prev = NULL;                      // 更新新头节点的prev指针
    }
    free(temp);
}

int main() {
    struct Node* head = NULL;
    
    insert(&head, 10);
    insert(&head, 20);
    insert(&head, 30);

    printf("Forward Traversal: ");
    Forward(head);

    printf("Backward Traversal: ");
    Backward(head);

    delete(&head);
    printf("After deleting head: ");
    Forward(head);

    return 0;
}
// 输出：
// Forward Traversal: 30 <-> 20 <-> 10 <-> NULL
// Backward Traversal: 10 <-> 20 <-> 30 <-> NULL
// After deleting head: 20 <-> 10 <-> NULL
```

---

### **4.2 循环链表**

循环链表是链表的一种特殊形式，其中**最后一个节点的`next`指针指向链表的头节点**，使得链表形成一个环状结构。

**循环链表两种类型**

1. **单向循环链表**：每个节点指向下一个节点，最后一个节点指向头节点。
2. **双向循环链表**：每个节点除了指向下一个节点外，还指向前一个节点，最后一个节点指向头节点，头节点的`prev`指针指向最后一个节点。

```c
// 单向循环链表
#include<stdio.h>
#include<stdlib.h>

struct Node {
    int data;
    struct Node* next;
}
struct Node* create(int data) {
    struct Node* new = (struct Node*)malloc(sizeof(struct Node));
    new->data = data;
    new->next = new;                   // 初始化为指向自己，形成循环
    return new;
}

void insert(struct Node** head, int data) {  // 插入节点到循环链表结尾
    struct Node* new = create(data);
    if(*head == NULL) {
        *head = new;
    } else {
        struct Node* temp = *head;           // 遍历到链表的最后一个节点
        while (temp->next != *head) {
            temp = temp->next;
        }
        temp->next = new;            // 将最后一个节点的next指针指向新节点
        new->next = *head;           // 新节点指向头节点，形成循环
    }
}
void print(struct Node* head) {      // 打印循环链表
    if (head == NULL) return;
    struct Node* temp = head;
    do {
        printf("%d -> ", temp->data);
        temp = temp->next;
    } while (temp != head);          // 如果回到头节点，则停止
    printf("(head)\n");
}

int main() {
    struct Node* head = NULL;

    insert(&head, 10);
    insert(&head, 20);
    insert(&head, 30);    

    print(head);

    return 0;
}
// 输出：
// 10 -> 20 -> 30 -> (head)
```

---

### **4.3 链表的高级操作：合并链表、反转链表**

**4.3.1 合并两个有序链表**

假设有两个已排序的链表，我们希望将它们合并为一个排序链表，将使用**归并**的方法。

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
};
struct Node* create(int data) {                         // 创建新节点
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}
struct Node* merge(struct Node* l1, struct Node* l2) {   // 合并两个有序链表
    struct Node* mergedHead = NULL;
    struct Node** tail = &mergedHead;

    while (l1 != NULL && l2 != NULL) {
        if (l1->data <= l2->data) {
            *tail = l1;
            l1 = l1->next;
        } else {
            *tail = l2;
            l2 = l2->next;
        }
        tail = &(*tail)->next;
    }

    if (l1 != NULL) {
        *tail = l1;
    } else {
        *tail = l2;
    }

    return mergedHead;
}
void print(struct Node* head) {     // 打印链表
    while (head != NULL) {
        printf("%d -> ", head->data);
        head = head->next;
    }
    printf("NULL\n");
}

int main() {
    struct Node* list1 = create(1);
    list1->next = create(3);
    list1->next->next = create(5);

    struct Node* list2 = create(2);
    list2->next = create(4);
    list2->next->next = create(6);

    printf("List 1: ");
    print(list1);
    printf("List 2: ");
    print(list2);

    struct Node* mergedList = merge(list1, list2);
    printf("Merged List: ");
    print(mergedList);

    return 0;
}
// 输出：
// List 1: 1 -> 3 -> 5 -> NULL
// List 2: 2 -> 4 -> 6 -> NULL
// Merged List: 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> NULL
```
**4.3.2 反转链表**

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {   // 定义单向链表节点结构
    int data;
    struct Node* next;
};
struct Node* create(int data) {    // 创建新节点
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

void insert(struct Node** head, int data) {    // 插入节点到链表尾部
    struct Node* newNode = create(data);
    if (*head == NULL) {
        *head = newNode;
    } else {
        struct Node* temp = *head;
        while (temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = newNode;
    }
}
void print(struct Node* head) {     // 打印链表
    struct Node* temp = head;
    while (temp != NULL) {
        printf("%d -> ", temp->data);
        temp = temp->next;
    }
    printf("NULL\n");
}
void reverse(struct Node** head) {   // 反转链表
    struct Node *prev = NULL, *current = *head, *next = NULL;
    
    while (current != NULL) {  // 遍历链表，反转每个节点的指针方向
        next = current->next;  // 保存当前节点的下一个节点
        current->next = prev;  // 反转当前节点的指针
        prev = current;        // 移动prev到当前节点
        current = next;        // 移动current到下一个节点
    }
    
    *head = prev;    // 更新头节点
}

int main() {
    struct Node* head = NULL;

    insert(&head, 10);    // 插入节点
    insert(&head, 20);
    insert(&head, 30);
    insert(&head, 40);
    insert(&head, 50);

    printf("Original List: ");    // 打印原链表
    print(head);

    reverse(&head);    // 反转链表

    printf("Reversed List: ");    // 打印反转后的链表
    print(head);

    return 0;
}
// 输出：
// Original List: 10 -> 20 -> 30 -> 40 -> 50 -> NULL
// Reversed List: 50 -> 40 -> 30 -> 20 -> 10 -> NULL
```
  
---