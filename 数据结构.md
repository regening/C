# 14天学习数据结构

## **DAY 1. C语言基础复习**

### 1.1 数据类型

C语言支持多种基本数据类型，以下是常见的类型：

* **整型（int）**：用于表示整数值。
* **字符型（char）**：用于表示单个字符。
* **浮点型（float, double）**：用于表示带小数的数值，`double`精度比`float`更高。
* **void**：表示无类型，通常用于函数返回值为空时。

**示例**：

```c
int a = 10;      // 整数类型
char c = 'A';    // 字符类型
float f = 3.14;  // 单精度浮点类型
double d = 3.14159; // 双精度浮点类型
```

---

### 1.2 数组与指针

**数组**：数组是一组相同类型数据的集合，可以通过索引访问。

**指针**：指针是一个变量，它存储的是另一个变量的地址。

* 数组名其实是指向数组首元素的指针。

**示例**：

```c
int arr[5] = {1, 2, 3, 4, 5};  // 数组定义
int *p = arr;  // 指针p指向数组arr的首元素

// 通过指针访问数组元素
printf("%d\n", *(p + 2));  // 输出3 (arr[2])
```

---

### 1.3 结构体

**结构体（struct）**：结构体是C语言中的一种自定义数据类型，用于将不同类型的数据组合在一起。

**示例**：

```c
struct Person {
    char name[20];
    int age;
};

struct Person p1 = {"Alice", 20};  // 创建结构体变量p1
printf("%s is %d years old.\n", p1.name, p1.age);   // 访问结构体成员
```
---


### 1.4 动态内存管理

在C语言中，使用`malloc`和`free`函数来动态分配和释放内存：

* `malloc(size)`：分配指定大小的内存。
* `free(ptr)`：释放通过`malloc`分配的内存。

**示例**：

```c
int *p = (int *)malloc(sizeof(int) * 5);  // 分配5个int大小的内存

if (p == NULL) {
    printf("Memory allocation failed.\n");
} else {
    p[0] = 10;  // 使用动态分配的内存
    printf("%d\n", p[0]);
    free(p);  // 释放内存
}
```

---

### **1.5 函数**

C语言中的函数是一个代码块，用于执行特定的任务。函数有返回值和参数。

**示例**：

```c
int add(int a, int b) { // 定义函数
    return a + b;
}

int main() {
    int result = add(5, 3);  // 调用函数
    printf("Result: %d\n", result);  // 输出8
    return 0;
}
```

---

## **DAY 2. 线性数据结构基础**

### **2.1 数组（Array）**

数组是存储相同类型元素的集合。它是线性数据结构的一种，能够通过索引（下标）直接访问元素。

**数组的特点**：

* **固定大小**：在声明时，数组的大小是固定的。
* **连续内存**：数组的元素在内存中是连续存储的。
* **随机访问**：通过下标可以直接访问任意元素，访问速度为O(1)。

**数组的基本操作**：

* **初始化**：在定义数组时可以为其元素赋初值。
* **访问元素**：通过下标访问元素。
* **修改元素**：直接通过下标修改元素值。

```c
#include <stdio.h>

int main() {
    int arr[5] = {1, 2, 3, 4, 5};  // 初始化数组

    for (int i = 0; i < 5; i++) {   // 遍历数组并打印元素
        printf("arr[%d] = %d\n", i, arr[i]);
    }

    arr[2] = 10;    // 修改数组元素
    printf("change arr[2] = %d\n", arr[2]);

    return 0;
}
// 输出：
// arr[0] = 1
// arr[1] = 2
// arr[2] = 3
// arr[3] = 4
// arr[4] = 5
// Updated arr[2] = 10
```

**ps**：数组的大小是固定的，不能动态改变。若需要动态大小，可以使用指针和`malloc`。

---

### **2.2 链表（Linked List）**

**链表****是一种灵活的线性数据结构，允许动态地管理数据。通过链表的指针，我们可以轻松地插入、删除和遍历数据。尽管它比数组在访问速度上稍逊一筹，但在内存管理和插入/删除操作上具有显著优势。

**链表**是一种动态的数据结构，它由一组**节点（Node）**组成。每个节点包含两部分：

1. **数据部分**：存储节点的数据。
2. **指针部分**：指向下一个节点的指针（或引用）。

与数组不同，链表的元素不在内存中是连续存储的，而是通过指针连接在一起。链表的大小是动态的，可以在运行时根据需要增加或删除节点。

---

**链表的结构：**

链表的基本结构由节点组成。每个节点包含：

* **数据部分**：存储数据。
* **指针部分**：指向下一个节点的指针，通常是一个指向结构体的指针。

```c
// 简单链表节点定义：
struct Node {
    int data;          // 数据部分
    struct Node* next; // 指向下一个节点的指针
};
```

---

**链表的种类：**

1. **单向链表（Singly Linked List）**：

   * 每个节点只包含一个指向下一个节点的指针。
   * 最后一个节点的指针指向`NULL`，表示链表的结束。

2. **双向链表（Doubly Linked List）**：

   * 每个节点包含两个指针：一个指向下一个节点，另一个指向前一个节点。
   * 可以从任意方向（前向或后向）遍历链表。

3. **循环链表（Circular Linked List）**：

   * 最后一个节点的指针指向头节点，形成一个环状结构。
   * 可以是单向循环链表或双向循环链表。

---

#### **优点**：

* **动态大小**：链表的大小是动态的，可以在运行时根据需要扩展或缩减，不需要提前定义大小。
* **高效的插入与删除**：链表的插入和删除操作（尤其是在头部或中间）是高效的，仅需要调整指针，不需要移动元素（不像数组那样）。
* **灵活的内存分配**：链表的节点在内存中不是连续存储的，可以更灵活地管理内存。

#### **缺点**：

* **访问速度慢**：链表的元素在内存中不连续，因此无法像数组一样通过索引直接访问，访问每个元素需要从头节点逐一遍历，时间复杂度为O(n)。
* **额外的空间开销**：每个节点需要额外存储一个指向下一个节点的指针，导致额外的空间开销。
* **指针管理复杂**：链表的指针操作比较复杂，容易出现指针错误，特别是在插入和删除操作时。

---

**链表应用场景：**

1. **动态数据结构**：当数据的数量在程序运行过程中不断变化时，链表提供了灵活的内存管理方式。
2. **需要频繁插入/删除的场景**：如果你需要频繁地在数据中间插入或删除元素，链表比数组更高效。
3. **队列和栈的实现**：链表可以方便地实现队列和栈这类数据结构。
4. **内存管理**：一些内存分配和垃圾回收机制也使用链表来跟踪和管理内存块。

---


### ** 2.3 链表应用 **


链表是一种动态数据结构，其中的元素（节点）包含数据部分和指向下一个节点的指针。链表的大小是动态的，可以在运行时调整。

**链表的特点**：

* **动态大小**：链表的大小在运行时可随时增加或减少。
* **节点存储**：每个节点包含数据和指向下一个节点的指针。
* **线性访问**：遍历链表时，必须从头节点开始，逐个访问下一个节点，直到到达链表的末尾。

**链表的基本操作**：

* **创建链表**：动态分配内存创建节点。
* **插入节点**：在链表头部、尾部或中间插入节点。
* **删除节点**：删除特定节点。
* **遍历链表**：从头节点开始遍历链表并访问每个节点的数据。

```c
// 实现一个简单的单向链表，包含插入、删除和遍历操作。
#include <stdio.h>
#include <stdlib.h>

struct Node {   // 定义节点结构体
    int data;
    struct Node *next;
};

struct Node* point(int data) {    // 创建一个新节点
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

void print(struct Node* head) {    // 遍历链表并打印节点数据
    struct Node* current = head;
    while (current != NULL) {
        printf("%d -> ", current->data);
        current = current->next;
    }
    printf("NULL\n");
}

void insert(struct Node** head, int data) {   // 插入节点到链表的头部
    struct Node* newNode = point(data);
    newNode->next = *head;
    *head = newNode;
}

void delete(struct Node** head) {   // 删除链表的头部节点
    if (*head != NULL) {
        struct Node* temp = *head;
        *head = (*head)->next;
        free(temp);
    }
}

int main() {
    struct Node* head = NULL;

    insert(&head, 10);    // 插入节点
    insert(&head, 20);
    insert(&head, 30);
    
    printf("Linked List: ");
    print(head);

    delete(&head);    // 删除头部节点
    printf("After deleting head: ");
    print(head);

    return 0;
}
// 输出：
// Linked List: 30 -> 20 -> 10 -> NULL
// After deleting head: 20 -> 10 -> NULL
```

---

### **2.4 数组与链表的比较**

| 特点        | 数组         | 链表            |
| --------- | ---------- | ------------- |
| **大小**    | 固定         | 动态            |
| **内存布局**  | 连续         | 非连续           |
| **访问时间**  | O(1)（随机访问） | O(n)（顺序访问）    |
| **插入/删除** | O(n)（移动元素） | O(1)（头部插入/删除） |
| **内存使用**  | 固定内存       | 动态内存          |

---

## **



